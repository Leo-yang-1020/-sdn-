## 链路差错修复平台达到的效果：

- 立刻定位到出错的位置，便于我们实际情况中进行差错的物理修复（因为我们的mininet的仿真的平台可以无缝移植到真实的应用场景，准确定位到真实的物理尤为重要）
- 定位到出错的最可能的设备：通过分析差错的链路分析具体情况，给出最可能出错的地方
  - 链路
  - 交换机
  - 主机

- 链路修复，在平时的使用里，可能我们来不及修复物理差错，为了保证服务器的正常运行，我们需要规划新的最短路径，我们可以重新规划我们的路径，如果故障链路是关键链路，被破坏后将不存在路径可以达到，则提示用户需要立刻人工修复。

## 实验流程

#### 构建拓扑

使用mininet构建拓扑：

拓扑的选择，我们选择了

实验六的那一条较为复杂的拓扑作为该次实验的拓扑图进行测试。

#### 拓扑ping通检测

利用onos原生流表，全局ping通，由此获取到devices信息，由北向接口调用并存储。

#### 差错检验与修复

可能出现的差错：

- 链路故障
- 交换机故障

对于不同的故障，都能被准确地识别，并且保证为主机提供的链路的选择在不出现差错的情况下，尽可能是最高效的。

#### 链路的检测原理

我们在学习Onos时可以知道，Onos探测交换机之间的链路利用了LLDP协议：

1)控制器首先向switch1下发packet_out消息，即是一个LLDP包，此时switch1将这个包从指定的的端口转发出去，此时别的交换机switch2收到该LLDP封包时，会通过PACKET_IN消息上报给控制器，这个时候控制器就可以知道switch1和switch2是相连的，并且方向时switch1到switch2是畅通的。这样，就完成一次链路发现检测。
2)如果PACKET_OUT的LLDP包并未PACKET_IN给控制器，则会下发BDDP包，BDDP包主要用于非OpenFlow交换机，与实验环境无关，因此不多加赘述。或者判定端口和主机相连，见后文分析。
3)LLDP包只有一跳存活时间的特性，也即是只存在于两个相邻的交换机中。

![img](https://img1.sdnlab.com/wp-content/uploads/2018/06/LLDP-Openflow-12.png)

而北向接口也正是利用这个原理来检测链路

我们在初始建立链路时，控制器就会发送LLDP检测包来获取全局的拓扑，这时，我们通过北向接口获取全局的链路信息，并将其存储。

为了建立并使用自己规划好的路径，我们需要给每一条交换机下发一条优先级为6的流表来屏蔽原生的优先级为5那一条匹配ip包的流表。

初始化规划的路径使用dijkstra算法，基于跳数规划。

之后，我们可以比较，使用控制器的原始流表下，两个主机间的带宽和使用我们自己规划的路线下的主机的带宽的差别。

在差错检验中，为了使得差错更加容易被我们识别出，我们使用VLC，播放一段视频，当视频中断时，我们就可以使用链路检测脚本，检测网络拓扑中哪一条链路出现了差错，再根据出现差错后拓扑，重新规划路线，消除差错。

#### 差错检测的方法

我们利用链路比较的方法，判断链路的故障源头。

在实际的生活中，我们常见的差错有：

- 链路差错
- 交换机差错
- 服务器主机怠机

对于每一项差错，我们都可以检验出来

当h1 ping h2失败时，我们可以执行检测脚本，检测会检测差错，以供用户发现差错的源头。

脚本会调用Onos的北向接口，Onos会发送LLDP检测包，全局检测链路信息，并将其转化为json格式的字典。

此时，我们可以将此时获取的链路信息与初始化时的链路信息作比较，遍历对比，由此得到出现差错的链路的信息。

差错检验后，为了使得用户能继续正常使用，我们会为用户重新规划一条可以使用的路线，使得用户视频继续播放。

#### 差错的制造：

在mininet环境中，模拟链路故障，可以执行 link s5 s6 down，使得交换机两个交换机之间的链路断开

模拟交换机故障可以使用，switch s1 down使得交换机怠机

#### 如何将差错归类并且准确识别差错位置？

我们通过执行linkCheck脚本，控制器会发送LLDP包检测各个链路的检测情况，与先前的链路对比，可以得出出现问题的链路的准确位置。

- 如果仅有一条链路，或者多条不相关的链路断裂，可以判断是链路本身的问题
- 如果是与某个交换机相关的所有链路全部断裂，那么我们基本可以认为是该交换机出现怠机
- 如果链路都不存在问题，但是视频流完全无法播放，可以认为是服务器主机出现了问题

判断某个交换机所有端口全部断开的方法：

首先，在遍历原来的links时，我们可以创建一个字典，记录所有交换机与端口的对应信息，字典的key是id,value是一个字典，这个字典的key是port,value为0表示该端口正常，为1表示该端口出现故障。

再用一个set存放所有出现了故障的链路所对应的两个交换机，

最后全部链路差错检验完成后，搜索set中出现过的交换机，如果该交换机的所有的端口均故障，我们可以给用户合理推测，推测为可能是交换机出现了故障。   

如果链路没有问题，但是故障仍然存在，我们可以推测是服务器主机出现了问题。                                                                                              

差错信息的判断可以帮助用户快速定位到错误，如果来不及马上处理差错，并且需要马上恢复使用，则可以重新规划路线。

### 路线规划与选择

使用迪杰斯特拉算法，构建两个主机之间的最短路。当构建好的某条链路被破坏时：重新计算最短路径并建立链接。

在图中，构建节点的方式选择：每一个交换机的每一个的端口视作一个节点，由于交换机转发速度相对于链路传输来说速度极快，我们便可以忽略OF交换机转发所需的时间，将同一个交换机的每个端口所代表的节点之间的距离设置为0。

对于交换机与交换机之间的端口之间的节点的距离，我们暂定选择1，即基于跳数的算法

#### 带宽监测可视化 

带宽测试得到的数据可以利用gnuplot，一个命令行的交互式绘图工具可视化，便于管理人工实时查看评价算法。

具体步骤如下：

1. 在Mininet创建好拓扑后，选择h1,h2进行tcp带宽测试

2. Xterm h1, h2,即打开两个虚拟主机的终端

3. 在终端h2中，执行命令

   ```bash
   iperf -s -p 5566 -i 1 > result
   #在h2的终端中，将h2设为服务器server，设置端口为5566，间隔时间1s，并将结果保存到文件result中
   ```

   在终端h1中，执行命令

   ```bash
   iperf -c 10.0.0.2 -p 5566 
   #在h1的终端中，将h1作为客户机client，连接到h2（ip地址为10.0.0.2），目标端口为5566，连接时间默认为10秒，可通过参数-t指定参数。
   ```

   之后，在服务器端运行shell脚本，使用gnuplot工具打印不同时间的测试带宽的数据

   这是写好的shell脚本，可以将获取到的iperf 两主机间的带宽测试的数据可视化。

   ```shell
   #! /bin/env bash
   cat result
   #以文本的格式展示TCP带宽测试结果
   cat result | grep sec | head -10 | tr - " " | awk '{print $4,$8}' > new_result
   #处理文本的格式，使得其格式服从gnuplot作图要求x,y轴对应值。
   gnuplot -persist << EOF
     set yrang [40:60]
     set xlabel "time (sec)"
     set ylabel "tcp throughput (Mbps)"
     plot "new_result" title "tcp flow" with linespoints
   EOF
   ```

   

#### 视频流程

1. 创建相应的mininet拓扑，并且连接onos控制器

   ```shell
   sudo mn --custom topoLab6.py --topo mytopo --controller=remote,ip=127.0.0.1,port=6653 --mac --switch=ovs,protocols=OpenFlow13
   ```

2. 在拓扑中首先调用getLinks.py脚本，检测并保存初始情况链路信息

3. 调用pingall，检测原始下发的流表对于ip包的转发功能

   ```shell
   pingall
   ```

5. 下发drop流表屏蔽onos原生流表的转发功能

   ```shell
   python3 add_drop_flows.py
   ```

6. 此时h1 ping h2会失败

   ```
   h1 ping h2
   ```

7. 调用dijkstraGraph，规划并产生h1到h2之间的路径，根据路径下发相应的流表

   ```shell
   python3 dijkstraGraph.py
   ```

9. 人为地制造链路差错，在mininet中使用： link   s6 s7  down

10. h1 ping h2 失败后，发现错误，此时执行差错检验程序: sh linkCheck.sh，检测出差错，并且重新规划路线

11. h1 ping h2成功ping通，路径也发生改变，说明已经避开差错

10. 恢复链路连接 link s6 s7 up

11. 人为地制造交换机差错，在mininet中使用命令行： switch s6 stop

12. 发现h1 ping h2失败后，我们可以调用网络检测修复shell脚本，检测并成功发现到链路错误，并且推测出是交换机的怠机问题，开始重新规划路线并下发脚本

13. h1 ping h2成功！

#### 顺序图



#### 用例图

两个参与者：控制器和用户